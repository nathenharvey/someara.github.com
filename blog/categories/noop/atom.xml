<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: noop | A Fistful of Servers]]></title>
  <link href="http://someara.github.com/blog/categories/noop/atom.xml" rel="self"/>
  <link href="http://someara.github.com/"/>
  <updated>2013-01-01T18:37:58-05:00</updated>
  <id>http://someara.github.com/</id>
  <author>
    <name><![CDATA[Sean OMeara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Promises, Lies, and Dry-Run Mode]]></title>
    <link href="http://someara.github.com/post/2012/12/21/promises-lies-and-dryrun-mode/"/>
    <updated>2012-12-21T04:20:00-05:00</updated>
    <id>http://someara.github.com/post/2012/12/21/promises-lies-and-dryrun-mode</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>


<p><img class="right" src="http://i.imgur.com/Ftyot.jpg" width="300"></p>

<p>"I need to know what this will do to my production systems before I run
it." -- Ask a Systems Administrator why they want dry-run mode in a
management tool, and this is the answer you'll get almost every single
time.</p>

<p>Historically, we have been able to use dry-run as a risk mitigation
strategy before applying changes to machines. Dry-run is supposed to
report what a tool would do, so that the administrator can determine
if it is safe to run. Unfortunately, this only works if the reporting
can be trusted as accurate.</p>

<p>In this post, I'll show why modern configuration management tools
behave differently than the classical tool set, and why their dry-run
reporting is untrustworthy. While useful for development, it should
never be used in place of proper testing.</p>

<h2> make -n </h2>


<p><img class="left" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Ford_assembly_line<em>-</em>1913.jpg/566px-Ford_assembly_line<em>-</em>1913.jpg" width="300"></p>

<p>Many tools in a sysadmin's belt have a dry-run mode. Common
utilities like make, rsync, rpm, and apt all have it.  Many databases
will let you simulate updates, and most disk utilities can show you
changes before making them.</p>

<p>The <a href=http://pubs.opengroup.org/onlinepubs/009695399/utilities/make.html">make</a>
utility is the earliest example I can find of an automation tool with
a dry-run option. Dry-run in <code>make -n</code> works by building a list of
commands, then printing instead of executing them. This is useful
because it can be trusted that <code>make</code> will always run the exact same
list in real-run mode. Rsync and others behave the same way.</p>

<p>Convergence based tools, however, don't build lists of commands. They
build sets of convergent operators instead.</p>

<h2> Convergent Operators, Sets and Sequence </h2>


<p><img class="right" src="http://i.imgur.com/x3uWr.png" width="300"></p>

<p>Convergent operators ensure state. They have a subject, and two sets of
instructions. The first set are tests that determine if the subject is
in the desired state, and the second set takes corrective actions if
needed. Types are made by grouping common tests and actions. This
allows us to talk about things like users, groups, files, and services
abstractly.</p>

<p>CFEngine promise bundles, Puppet manifests, and Chef recipes are all
sets of these data structures. Putting them into a <a
href="http://en.wikipedia.org/wiki/Control_theory">feedback loop</a>
lets them cooperate over multiple runs, and enables the self-healing
behavior that is essential when dealing with large amounts of
complexity.</p>

<p><img class="left" src="http://i.imgur.com/g4fcW.png" width="300"></p>

<p>During each run, <em>ordered sets</em> of convergent operators are applied
against the system. How order is determined varies from tool to tool,
but it is ordered none the less.</p>

<h2> Promises and Lies </h2>


<p><img class="left" src="http://i.imgur.com/rUk4d.png" width="350">
CFEngine models <a href="http://en.wikipedia.org/wiki/Promise_theory">Promise Theory</a>
as a way of doing systems management. While Puppet and Chef do not model
promise theory explicitly, it is still useful to borrow its vocabulary
and metaphors and think about individual, autonomous agents that
promise to fix the things they're concerned with.</p>

<p>When writing policy, imagine every resource statement as a simple
little robot. When the client runs, a swarm of these robots run
tests, interrogate package managers, inspect files, and examine
process tables. Corrective action is taken only when necessary.</p>

<p>When dealing with these agents, it can sometimes seem like they're
lying to you. This raises a few questions. Why would they lie? Under
what circumstances are they likely to lie? What exactly is a lie
anyway?</p>

<p>A <a href="http://cfengine.com/markburgess/BookOfPromises.pdf">formal</a>
examination of promises does indeed include the notion of lies. Lies
can be outright deceptions, which are the lies of the
rarely-encountered Evil Robots. Lies can also be "non-deceptions",
which are the lies of occasionally-encountered Broken Robots. Most
often though, we experience lies from the often-encountered Merely
Mis-informed Robots.</p>

<h2> The Best You Can Do </h2>


<p><img class="left" src="http://i.imgur.com/oyf5b.png" width="300"></p>

<p>The best you can possibly hope to do in a dry-run mode is to build the operator
sequences, then interrogate each one about what they would do to
repair the system at that exact moment. The problem with this is, in real-run
mode, the <em>the system is changing between the tests</em>. Quite often, the
results of any given test will be affected by a preceeding action.</p>

<p><img class="right" src="http://i.imgur.com/uKQHY.png" width="300"></p>

<p>Configuration operations can have rather large side effects. Sending
signals to processes can change files on disk. Mounting a disk will
change and entire branch of a directory tree. Packages can drop off
one or a million different files, and will often execute pre or
post-installation scripts. Installing the Postfix package on an Ubuntu
system will not only write the package contents to disk, but also
create users and disable Exim before automatically starting the service.</p>

<p>Throw in some notifications and boolean checks and things can get
really interesting.</p>

<h2> Experiments with Robots </h2>


<p><img class="right" src="http://i.imgur.com/4ORuB.jpg" width="250" height="350"></p>

<p>To experiment with dry-run mode, I wrote a Chef cookbook that
configures a machine with initial conditions, then drops off CFEngine
and Puppet policies for dry-running.</p>

<p>Three configuration management systems, each with conflicting
policies, wreaking havoc on a single machine sounds like a fun way to
spend the evening. Lets get weird.</p>

<p>If you already have a Ruby and Vagrant environment setup on your
workstation and would like to follow along, feel free. Otherwise, you
can just read the code examples by clicking on the provided links as
we go.</p>

<p>Clone out the <a href='https://github.com/someara/dry-run-lies-cookbook'>dry-run-lies</a>
cookbook from Github, then bring up a Vagrant box with Chef.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/src/$ git clone https://github.com/someara/dry-run-lies-cookbook dry-run-lies
</span><span class='line'>~/src/$ cd dry-run-lies
</span><span class='line'>~/src/dry-run-lies$ bundle install
</span><span class='line'>~/src/dry-run-lies$ bundle exec vagrant up
</span><span class='line'>~/src/dry-run-lies$ bundle exec vagrant ssh</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2> CFEngine --dry-run </h2>


<p>When Chef is done configuring the machine, log into it and switch to
root. We can test the <code>/tmp/lies-1.cf</code> policy file by running <code>cf-agent</code> with the <code>-n</code> flag.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>CFEngine dry-run  </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# cf-agent -K -f /tmp/lies-1.cf -n
</span><span class='line'>-> Would execute script /bin/echo hello from bundle_one. puppet_bin_does_not_exist
</span><span class='line'> -> Need to execute /usr/bin/aptitude update...</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Dry-run mode reports that would run an echo command in bundle_one.
Let's remove <code>-n</code> and see what happens.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>CFEngine real-run  </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# cf-agent -K -f /tmp/lies-1.cf
</span><span class='line'>Q: ".../bin/echo hello": hello from bundle_one.
</span><span class='line'>puppet_bin_does_not_exist
</span><span class='line'>I: Last 1 quoted lines were generated by promiser "/bin/echo hello from bundle_one. puppet_bin_does_not_exist"
</span><span class='line'>Q: ".../bin/echo hello": hello from bundle_three. puppet_bin_exists
</span><span class='line'>I: Last 1 quoted lines were generated by promiser "/bin/echo hello from bundle_three. puppet_bin_exists"</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Wait a sec... What's all this bundle_three business? Did dry-run just
lie to me?</p>

<p>Examine the <code>lies-1.cf</code> file <a href="http://bit.ly/RVnV38">here</a>.</p>

<p>The policy said three things. First, "echo hello from bundle one if
/usr/bin/puppet does NOT exist". Second, "make sure the puppet package
is installed". Third, "echo hello from bundle three if /usr/bin/puppet
exists."</p>

<p>In dry-run mode, each agent was interrogated individually. This resulted
in a report leading us to believe that only one "echo hello" would be
made, when in reality, there were two.</p>

<h2> Puppet --noop </h2>


<p>Let's give Puppet a spin. We can test the policy at <code>/tmp/lies-1.pp</code> with the
<code>--noop</code> flag to see what Puppet thinks it will do.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Puppet dry-run  </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# puppet apply /tmp/lies-1.pp --noop
</span><span class='line'>notice: /Stage[main]//Mount[/mnt/nfsmount]/ensure: current_value ghost, should be unmounted (noop)
</span><span class='line'>notice: /Stage[main]//Mount[/mnt/nfsmount]: Would have triggered 'refresh' from 1 events
</span><span class='line'>notice: Class[Main]: Would have triggered 'refresh' from 3 events
</span><span class='line'>notice: Stage[main]: Would have triggered 'refresh' from 1 events
</span><span class='line'>notice: Finished catalog run in 0.30 seconds</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Dry-run reports that there is one resource to fix. Excellent. Let's
remove the <code>--noop</code> flag and see what happens.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Puppet real-run </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# puppet apply /tmp/lies-1.pp
</span><span class='line'>notice: /Stage[main]//Mount[/mnt/nfsmount]/ensure: ensure changed 'ghost' to 'unmounted'
</span><span class='line'>notice: /Stage[main]//Mount[/mnt/nfsmount]: Triggered 'refresh' from 1 events
</span><span class='line'>notice: /Stage[main]//File[/mnt/nfsmount/file-1]/ensure: created
</span><span class='line'>notice: /Stage[main]//File[/mnt/nfsmount/file-2]/ensure: created
</span><span class='line'>notice: /Stage[main]//File[/mnt/nfsmount/file-3]/ensure: created
</span><span class='line'>notice: Finished catalog run in 4.37 seconds</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Like the CFEngine example, we have the real-run doing things that were
not listed in the dry-run report.</p>

<p>The Chef policy that set up the initial machine state mounted an NFS
directory into <code>/mnt/nfssrv</code>. When interrogated during dry-run, the
tests in the <code>file</code> resources saw that the files were present, so they
did not report that they needed to be fixed. During the real-run,
Puppet unmounts the directory, changing the view of the filesystem and
the outcome of the tests.</p>

<p>Check out the policy <a href="http://bit.ly/V87wom">here</a>.</p>

<p>It should be noted that Puppet's resource graph model does nothing to
enable noop functionality, nor can it affect its accuracy. It used
only for the purposes of ordering and ensuring non-conflicting node
names within its model.</p>

<h2> Chef --why-run </h2>


<p>Finally, we'll run the original Chef policy with the <code>-W</code> flag to see if it lies like the others.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# chef-solo -c /tmp/vagrant-chef-1/solo.rb -j /tmp/vagrant-chef-1/dna.json -Fmin --why-run
</span><span class='line'>Starting Chef Client, version 10.16.4
</span><span class='line'>Compiling cookbooks .......done.
</span><span class='line'>Converging 32 resources .........................U.......UUUS
</span><span class='line'>System converged.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>resources updated this run:
</span><span class='line'>* mount[/mnt/nfsmount]
</span><span class='line'>- mount 127.0.0.1:/srv/nfssrv to /mnt/nfsmount&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>package[nmap]&lt;/li>
</span><span class='line'>&lt;li>&lt;p>install version 5.21-1.1ubuntu1 of package nmap&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>package[puppet]&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>remove  package puppet&lt;/li>
</span><span class='line'>&lt;li>&lt;p>purge  package puppet&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>package[puppet-common]&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>remove  package puppet-common&lt;/li>
</span><span class='line'>&lt;li>purge  package puppet-common&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>chef client finished, 4 resources updated</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Seems legit. Let's remove the <code>--why-run</code> flag and do it for real.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@dry-run-lies:~# chef-solo -c /tmp/vagrant-chef-1/solo.rb -j /tmp/vagrant-chef-1/dna.json -Fmin
</span><span class='line'>Starting Chef Client, version 10.16.4
</span><span class='line'>Compiling cookbooks .......done.
</span><span class='line'>Converging 32 resources .........................U.......UUUU
</span><span class='line'>System converged.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>resources updated this run:
</span><span class='line'>* mount[/mnt/nfsmount]
</span><span class='line'>- mount 127.0.0.1:/srv/nfssrv to /mnt/nfsmount&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>package[nmap]&lt;/li>
</span><span class='line'>&lt;li>&lt;p>install version 5.21-1.1ubuntu1 of package nmap&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>package[puppet]&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>remove  package puppet&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>package[puppet-common]&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>remove  package puppet-common&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>execute[hack the planet]&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>execute /bin/echo HACKING THE PLANET&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>chef client finished, 5 resources updated</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Right. "HACKING THE PLANET" was definitely not in the dry-run output.
Let's go figure out what happened. See the Chef policy <a href="http://bit.ly/WXr8k0">here</a>.</p>

<p>Previously, our CFEngine policy had installed Puppet on the machine.
Our Puppet policy ensured nmap was absent. Chef will install nmap, but
only if the Puppet binary is present in /usr/bin.</p>

<p>Running Chef in <code>--why-run</code> mode, the test for the <code>'package[nmap]'</code> resource
succeeds because of the pre-conditions set up by the CFEngine policy.
Had we not applied that policy, the <code>'execute[hack the planet]'</code>
resource would still not have fired because nothing had installed the
nmap package along the way. In real-run mode, it succeeds because Chef
changes the machine state between tests, but would have failed if we
had never ran the Puppet policy.</p>

<p>Yikes.</p>

<h2> Okay, So What? </h2>


<p>The robots were not trying to be deceptive. Each autonomous agent
told us what it honestly thought it should do in order to fix the
system. As far as they could see, everything was fine when we asked
them.</p>

<p>As we automate the world around us, it is important to know how the
systems we build fail. We are going to need to fix them, after all.
It is even more important to know how our machines lie to us. The last
thing we need is an army of lying robots wandering around.</p>

<p>Luckily, there are a number of techniques for testing and introducing
change that can be used to help ensure nothing bad happens.</p>

<h2> Keeping the Machines Honest </h2>


<p><img class="right" src="http://farm8.staticflickr.com/7171/6809694353_7bdba3a38a_n.jpg" width="280"></p>

<p>Testing needs to be about observation, not interrogation. In each
case, the system converged to the policy, regardless of whether
dry-run got confused or not. If we can setup up a test machine that
reproduce a system's state, we can real-run the policy and observe the
behavior. Integration tests can then be written to ensure that the
policy achieves what you mean it to.</p>

<p>Ideally, test machines are modeled with policy from the ground up,
starting with Just Enough Operating System to allow them to run Chef.
This ensures all the details of the system have been captured and are
reproducible.</p>

<p>Other ways of reproducing state work, but come with the burden of
having to drag that knowledge around with you. Snapshots, kickstart or
bootstrap scripts, and even manual configuration will all work so long
as you can promise they're accurate.</p>

<p>There are some situations where reproducing a test system is
impossible, or modeling it from the ground up is not an option. In
this case, a slow, careful, incremental application of policy, aided
by dry-run mode and human intuition is the safest way to start. Chef's
why-run mode can help aide intuition by publishing assumptions about
what's going on. "I would start the service, assuming the software had
been previously installed" helps quite a bit during development.</p>

<p>Finally, increasing the resolution of our policies will help the most
in the long term. The more robots the better. Ensuring the contents of
configuration files is good. Making sure that they are only ones
present in a conf.d directory is better. As a community, we need to
produce as much high quality, trusted, tested, and reuseable policy as
possible.</p>

<p>Good luck, and be careful out there.</p>

<p>-s</p>
]]></content>
  </entry>
  
</feed>
